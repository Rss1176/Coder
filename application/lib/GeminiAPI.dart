import 'dart:convert';
import 'package:http/http.dart' as http;
import  'package:flutter_dotenv/flutter_dotenv.dart';

class GeminiAIService {
  // used gemini itself to guide this class, the first version of this class I persoanlly built but I used Gen Ai to help diagnose issues with the parsing into the correct format
 
  Future<Map<String, dynamic>> generateQuestions(String? abilityLevel, String? codingLanguage) async{
    final String apiKey = dotenv.env['GEMINI_API_KEY']!; // API key added to env vars
    final String modelName = dotenv.env['GEMINI_MODEL']!; // Your seleceted Gemini model (originally developed with gemini-1.5-pro-002)
    final String endpoint = "https://generativelanguage.googleapis.com/v1/models/$modelName:generateContent";
    // async function that saves the questions generated by the API as a map (dictionary for python)
    // takes 2 input parameters, one for the ability level of the user pulled from firebase and there self selected coding language of choice
    // a map is used as a JSON is returned by API, returned in parts - questions, options (possible answers), the answer, and an explination are saved seperatly

    // json response
    final Map<String, dynamic> requestBody = {
      "contents": [
        {
          "parts": [
            {
              "text": 
                'Generate a multiple-choice question about $codingLanguage. No single part of the response should be longer than 20 words, try to avoid asking print questions\n'
                'It should be aimed at someone at a $abilityLevel level.\n'
                'Please verify your question and answer before sending. Return the response in JSON format following this structure, ensuring the answer only returns a letter:\n'
                '{\n'
                '  "question": "The question itself",\n'
                '  "options": ["A", "B", "C", "D"],\n'
                '  "answer": "A",\n'
                '  "explanation": "A short explanation"\n'
                '}'
            }
          ]
        }
      ]
    };

    // try to connect to the AI through the generated API URL
    try {
      final response = await http.post(
        Uri.parse('$endpoint?key=$apiKey'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode(requestBody),
      );

      // if the URL connects sucessfully (code 200)
      if (response.statusCode == 200) {
        final Map<String, dynamic> data = jsonDecode(response.body);
        final List<dynamic> candidates = data['candidates'] as List<dynamic>;

      // split the full json into seperate strings in a map
        if (candidates.isNotEmpty) {
          final List<dynamic>? contentParts = candidates[0]['content']['parts'] as List<dynamic>?;

      // if the map has been generated successfully and the fields are not empty
          if (contentParts != null && contentParts.isNotEmpty) {
            String rawJson = contentParts[0]['text']; // raw json data taken from map
            rawJson = rawJson.replaceAll("```json", "").replaceAll("```", "").trim(); // remove the json identifier characters ``` and whitespace
            final Map<String, dynamic> content = jsonDecode(rawJson); // decode the json into a string 
            //split json into useable variables
            return {
              'question': content['question'],
              'optionA': content['options'][0],
              'optionB': content['options'][1],
              'optionC': content['options'][2],
              'optionD': content['options'][3],
              'answer': content['answer'],
              'explanation': content['explanation'],
            };
          }
        }

        return {"error": "Unexpected Response format: ${response.body}"};
      } else {
        return {
          "error": "HTTP request failed ${response.statusCode}: ${response.body}"
        };
      }
    } catch (e) {
      return {"error": "An error occurred: $e"};
    }
  }
}