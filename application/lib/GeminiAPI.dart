import 'dart:convert';
import 'package:http/http.dart' as http;

class GeminiAIService {
  // used gemini itself to guide this class, the first version of this class I persoanlly built but I used Gen Ai to help diagnose issues with the parsing into the correct format
 
  Future<Map<String, dynamic>> generateQuestions(String? abilityLevel, String? codingLanguage) async{
    final String apiKey = 'AIzaSyDfywIO2QbAMrFgst3Bj1abS6jm0SrYVyY'; // API key - connects to google cloud account
    final String modelName = 'gemini-1.5-pro-002'; // Selected model in Googles AI suite - saved as seperate variable as was changed in debugging and allows changing for updates/AI patches 
    final String endpoint = "https://generativelanguage.googleapis.com/v1/models/$modelName:generateContent";
    // async function that saves the questions generated by the API as a map (dictionary for python)
    // takes 2 input parameters, one for the ability level of the user pulled from firebase and there self selected coding language of choice
    // a map is used as a JSON is returned by API, returned in parts - questions, options (possible answers), the answer, and an explination are saved seperatly

    final Map<String, dynamic> requestBody = {
      "contents": [
        {
          "parts": [
            {
              "text": 
                'Generate a multiple-choice question about $codingLanguage. No single part of the response should be longer than 20 words\n'
                'It should be aimed at someone at a $abilityLevel level.\n'
                'Return the response in JSON format following this structure:\n'
                '{\n'
                '  "question": "The question itself",\n'
                '  "options": ["A", "B", "C", "D"],\n'
                '  "answer": "A",\n'
                '  "explanation": "A short explanation"\n'
                '}'
            }
          ]
        }
      ]
    };

    try {
      final response = await http.post(
        Uri.parse('$endpoint?key=$apiKey'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode(requestBody),
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> data = jsonDecode(response.body);
        final List<dynamic> candidates = data['candidates'] as List<dynamic>;

        if (candidates.isNotEmpty) {
          final List<dynamic>? contentParts = candidates[0]['content']['parts'] as List<dynamic>?;

          if (contentParts != null && contentParts.isNotEmpty) {
            String rawJson = contentParts[0]['text']; 
            rawJson = rawJson.replaceAll("```json", "").replaceAll("```", "").trim();
            final Map<String, dynamic> content = jsonDecode(rawJson); 

            return {
              'question': content['question'],
              'optionA': content['options'][0],
              'optionB': content['options'][1],
              'optionC': content['options'][2],
              'optionD': content['options'][3],
              'answer': content['answer'],
              'explanation': content['explanation'],
            };
          }
        }

        return {"error": "Unexpected Response format: ${response.body}"};
      } else {
        return {
          "error": "HTTP request failed ${response.statusCode}: ${response.body}"
        };
      }
    } catch (e) {
      return {"error": "An error occurred: $e"};
    }
  }
}