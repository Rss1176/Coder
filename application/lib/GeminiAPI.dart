import 'dart:convert';
import 'package:http/http.dart' as http;

class GeminiAIService {
  
  Future<Map<String, dynamic>> generateQuestions(String? abilityLevel, String? codingLanguage) async{
    // async function that saves the questions generated by the API as a map (dictionary for python)
    // takes 2 input parameters, one for the ability level of the user pulled from firebase and there self selected coding language of choice
    // a map is used as a JSON is returned by API, returned in parts - questions, options (possible answers), the answer, and an explination are saved seperatly  

    final String apiKey = 'AIzaSyAZxxFD_mRrNw60wuJfzD4ykUxItEEw9Nw'; // API key - connects to google cloud account
    final String modelName = 'gemini-1.5-pro-002'; // Selected model in Googles AI suite - saved as seperate variable as was changed in debugging and allows changing for updates/AI patches
    final String endpoint = "https://generativelanguage.googleapis.com/v1/models/$modelName:generateContent"; // URL endpoint of the API 

    try {
      final questionResponse = await http.post( // async function using the http package that goes to the API URL and awaits questions
        Uri.parse(endpoint + '?key=$apiKey'), // combines the end point with the api key creating the link to the AI account, the URI.parse calls to the https address, it really should use interpolation but I got it to work and dont wanna touch it
        headers: {"Content-Type": "application/json"}, // sets headers for JSON
        body: jsonEncode({ // transposes the prompt into a JSON format to send to the API
          "contents": [{"parts":[ //customised prompt to recieve correct data format/data from the API, coding language and ability level arguments used in the prompt
            {"text" : 
                      """Generate a multiple choice question about the coding langauge $codingLanguage"
                      "It should be aimed at someone at a $abilityLevel level"
                      "There should be 4 answers to the questions. each seperated by a \n character"
                      "the next part of the response should be the correct answer, i.e A,B,C,D with the final part being C,
                      the final part of the response should be a short explination ~20 words
                      """} //used """ for multiline strings and readability
            ]
            }
          ]
        })
      ); // logic assumes that no one text string will be longer than a full JSON line


      if (questionResponse.statusCode == 200) { // enssure http has connected properly with a response
        final data = jsonDecode(questionResponse.body); // Decodes the JSON data back into a string
        String textResponse = data['candidates'][0]['content']['parts'][0]['text']; // Reads JSON string data, these headings are produced by API, saves into one long string
        List<String> lines = textResponse.split('\n'); // splits the strings into individual lines such that variables can be assigned to them
        String finishedQuestion = lines[0]; //first line is the question
        List<String> options = lines.sublist(1, 5);  // possible responses takes up the next 4 lines
        String answer = lines[6];  // gemini produced answer is on line 6
        String explination = lines.sublist(7,10).join(''); //everyline after 6 is the explination, combines all the lines after 6 into a list before joining them together as a string with a whitespace seperator

        //seperate the list of strings into individual variables for easy use later
        String optionA = options[0];
        String optionB = options[1];
        String optionC = options[2];
        String optionD = options[3];


        return {
          "question": finishedQuestion,
          "optionA" : optionA,
          "optionB" : optionB,
          "optionC" : optionC,
          "optionD" : optionD,
          "answer" : answer,
          "explination" : explination
        }; // returns the map with the variables set tp their corresponding string headings
      } else {
          return {"failure to complete http ai request": "the body said: ${questionResponse.body}"}; // error checking if http does connect (i.e status != 200)
      }
    }
    catch (e){
      return {"error status 200 not met": "$e"}; //further error checking, catches any excpetion that occurs outwith the data being sent back i.e. failure to send prompt, wrong URL, etc
    }
  }
}
